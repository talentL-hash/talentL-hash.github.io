<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>泛型算法</title>
    <link href="/2020/07/05/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/05/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="10-3-2lambda表达式"><a href="#10-3-2lambda表达式" class="headerlink" title="10.3.2lambda表达式"></a>10.3.2lambda表达式</h3><p><strong>[capture list] (parameter list) -&gt; return type{function body}</strong></p><p>capture list捕获列表：局部变量的列表</p><p>必须使用尾置返回类型。</p><p>可以忽略参数列表和返回类型，但是必须包含捕获列表和函数体</p><p>auto f = [] {return 42};</p><p>使用<strong>条件运算符</strong>或者<strong>直接返回</strong>时，不用显式指出返回类型。</p><h3 id="10-3-3lambda捕获和返回"><a href="#10-3-3lambda捕获和返回" class="headerlink" title="10.3.3lambda捕获和返回"></a>10.3.3lambda捕获和返回</h3><p><strong>空捕获列表</strong>：[]</p><p><strong>值捕获</strong>：auto f = [v1] {return v1;};</p><p><strong>引用捕获</strong>：auto f2=[&amp;v1]{return v1;};</p><p>(采用引用捕获必须确保被引用的对象在lambda在执行的时候是存在的。)</p><p>捕获ostream的引用</p><p>[&amp;os,c] (const string &amp;) {os&lt;&lt;s&lt;&lt;c;};</p><p><strong>隐式捕获</strong>：让编译器根据lambda提中的代码推断我们要只用哪些变量。[=]采用捕获值方式，[&amp;]采用捕获引用方式。</p><p>当混合使用隐式捕获和显式捕获，捕获列表中的第一个元素必须是&amp;或者=。</p><p><strong>可变lambda</strong></p><p>值捕获 auto f = [v1] () <strong>mutable</strong>{ return ++v1;};</p><p>引用捕获的变量是否可以修改依赖于此引用指向的是一个const类型还是非const类型。</p><h3 id="10-3-4参数绑定"><a href="#10-3-4参数绑定" class="headerlink" title="10.3.4参数绑定"></a>10.3.4参数绑定</h3><p>多个地方执行相同的操作，通常定义一个函数。</p><p>lambda的捕获列表为空，通常可以用函数代替它。对于捕获列表不为空，情况更复杂。</p><p><strong>bind函数</strong><functional></p><p>可以看成一个通用的函数适配器</p><p>auto newCallable = bind(callable,arg_list)</p><p>arg_list可能包含_1, _2这种占位符，表示生成可调用对象中参数的位置。</p><pre><code class="hljs lisp">auto wc = find_if(<span class="hljs-name">words</span>.begin(), words.end(),bind(<span class="hljs-name">check_size</span>,_1,sz))<span class="hljs-comment">;</span></code></pre><p>using std::placeholders::_1;</p><p>所以使用using namespace placeholder;</p><p><strong>可以用bind绑定给定可调用对象中的参数或重新安排其顺序。</strong></p><p>auto g = bind(f, a, b, _2, c, _1);</p><p>g(X,Y) =&gt; f(a,b,Y,c,X);</p><p><strong>绑定引用参数</strong></p><p>使用标准库<strong>ref</strong>函数</p><pre><code class="hljs lisp">for_each(<span class="hljs-name">words</span>.begin(), words.end(),bind(<span class="hljs-name">print</span>,ref(<span class="hljs-name">os</span>),_1 ,' '))<span class="hljs-comment">;</span></code></pre><h2 id="10-4再探迭代器"><a href="#10-4再探迭代器" class="headerlink" title="10.4再探迭代器"></a>10.4再探迭代器</h2><h3 id="10-4-1插入迭代器"><a href="#10-4-1插入迭代器" class="headerlink" title="10.4.1插入迭代器"></a>10.4.1插入迭代器</h3><p>是一种迭代器适配器</p><p>it=t;//在it指定的当前尾置插入值t。</p><p>插入迭代器的三种类型，在于元素插入尾置：</p><ul><li>back_inserter ：push_back</li><li>front_inserter ：push_front</li><li>inserter: 第二个参数，元素必须被插入给定迭代器所表示的元素之前。</li></ul><p>list<int> lst={1,2,3,4},lst3;</p><p>copy(lst.begin(), lst.end(), inserter(lst3,lst3.begin()));//lst3={1,2,3,4}</p><h3 id="10-4-2-iostream迭代器"><a href="#10-4-2-iostream迭代器" class="headerlink" title="10.4.2 iostream迭代器"></a>10.4.2 iostream迭代器</h3><ul><li>istream_iterator</li></ul><pre><code class="hljs perl">istream_iterator&lt;<span class="hljs-keyword">int</span>&gt; in(cin), <span class="hljs-keyword">eof</span>;<span class="hljs-regexp">//in</span>:从cin读取<span class="hljs-keyword">int</span>，<span class="hljs-keyword">eof</span>: istream尾后迭代器cout &lt;&lt; accumulate(in, <span class="hljs-keyword">eof</span>, <span class="hljs-number">0</span>)&lt;&lt;endl;</code></pre><pre><code class="hljs ebnf"><span class="hljs-attribute">Sales_item sum</span> = *iterm_iter++;</code></pre><ul><li>ostream_iterator</li></ul><pre><code class="hljs cpp"><span class="hljs-function">ostream_iterator&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">out_iter</span><span class="hljs-params">(<span class="hljs-built_in">cout</span>, <span class="hljs-string">" "</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:vec)out_iter=e;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;</code></pre><pre><code class="hljs gauss"><span class="hljs-built_in">copy</span>(<span class="hljs-built_in">vec</span>.<span class="hljs-built_in">begin</span>(),<span class="hljs-built_in">vec</span>.<span class="hljs-keyword">end</span>(),out_iter);</code></pre><h3 id="10-4-3反向迭代器"><a href="#10-4-3反向迭代器" class="headerlink" title="10.4.3反向迭代器"></a>10.4.3反向迭代器</h3><p>只能从既支持++又支持–的迭代器来定义反向迭代器。排除forward_list和流迭代器。</p><ul><li>reverse_iterator</li></ul><p>将反向迭代器转换回普通迭代器需要调用reverse_iterator的base成员。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>15面向对象程序设计</title>
    <link href="/2020/07/05/15%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/07/05/15%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="15-面向对象程序设计"><a href="#15-面向对象程序设计" class="headerlink" title="15 面向对象程序设计"></a>15 面向对象程序设计</h1><h2 id="15-1-OOP：概述"><a href="#15-1-OOP：概述" class="headerlink" title="15.1 OOP：概述"></a>15.1 OOP：概述</h2><p>数据抽象：将类的接口与实现分离</p><p>继承：定义相似的类型并对其相似关系建模</p><p>动态绑定：忽略类型的区别，以同一的方式使用它们的对象</p><h3 id="继承（inheritance）"><a href="#继承（inheritance）" class="headerlink" title="继承（inheritance）"></a>继承（inheritance）</h3><p>类构成层次关系。<strong>基类（base class）</strong>、<strong>派生类（derived class）</strong></p><p>基类定义在层次关系中<strong>所有类共同拥有的成员</strong>，而每个派生类定义<strong>各自特有的成员</strong>。</p><p>对于某些函数，基类希望它的派生类各自定义合适自身的版本，基类将这些函数声明成<strong>虚函数（virtual function）</strong>。</p><p>派生类必须使用<strong>类派生列表（class derivation list）</strong>明确指出从哪个基类派生而来。形式：一个冒号，逗号分隔的基类列表，每个基类前有访问说明符。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Bulk_quote</span> : <span class="hljs-symbol">public</span> <span class="hljs-symbol">Quote</span>&#123;</code></pre><p>派生类必须在其内部对所有重新定义的虚函数进行声明。（可以）在这样的函数前加virtual。</p><p>C++11允许派生类显式地注明使用哪个成员函数改写基类的虚函数，<strong>override</strong>关键字。</p><h3 id="动态绑定（dynamic-binding）"><a href="#动态绑定（dynamic-binding）" class="headerlink" title="动态绑定（dynamic binding）"></a>动态绑定（dynamic binding）</h3><pre><code class="hljs reasonml">double print<span class="hljs-constructor">_total(<span class="hljs-params">ostream</span> &amp;<span class="hljs-params">os</span>, <span class="hljs-params">const</span> Quote &amp;<span class="hljs-params">item</span>)</span>&#123;item.net<span class="hljs-constructor">_price()</span>...&#125;</code></pre><p>既能使用基类Quote的对象调用该函数，也能使用派生类Bulk_quote的对象调用它。</p><p>实际传入的对象类型决定执行哪个版本的net_price。</p><p>上述过程中，函数的运行版本由实参决定，即在<strong>运行时</strong>选择函数的版本，所以动态绑定有时也称为<strong>运行时绑定（run-time binding）</strong>。</p><p><strong>使用基类的引用（或指针）调用一个虚函数时发生动态绑定。</strong></p><h2 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h2><h3 id="15-2-1-定义基类"><a href="#15-2-1-定义基类" class="headerlink" title="15.2.1 定义基类"></a>15.2.1 定义基类</h3><p>基类通常定义一个虚析构函数，即使该函数不执行任何实际操作。</p><h4 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h4><p>区分两种成员函数：</p><ul><li>基类希望派生类override的函数，定义为虚函数</li><li>基类希望派生类直接继承的函数</li></ul><p><strong>任何构造函数之外的非静态函数都可以是虚函数。</strong></p><p>关键字virtual只能出现在<strong>类内部</strong>的声明语句之前。</p><p>基类中声明虚函数，在派生类中隐式地也是虚函数。</p><p>成员函数如果没有声明为虚函数，则其解析过程发生在编译时而非运行时。</p><h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><p>和其他使用基类的代码一样，派生类能够访问公有成员，而不能访问私有成员。</p><p>基类希望派生类有权访问，同时禁止其他用户访问，使用<strong>protected访问运算符</strong>说明这样的成员。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>12 动态内存</title>
    <link href="/2020/07/05/12%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <url>/2020/07/05/12%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="12动态内存"><a href="#12动态内存" class="headerlink" title="12动态内存"></a>12动态内存</h1><table><thead><tr><th></th><th>分配</th><th>销毁</th></tr></thead><tbody><tr><td>全局对象</td><td>程序启动时</td><td>程序结束时</td></tr><tr><td>局部自动对象</td><td>进入其定义所在程序块</td><td>离开时</td></tr><tr><td>局部static对象</td><td>在第一次使用前</td><td>程序介数时</td></tr><tr><td>动态分配对象</td><td></td><td>显式地释放（与在哪里创建无关）</td></tr></tbody></table><p>静态内存：保存局部static对象。</p><p>栈内存：保存定义在函数内的非static对象。</p><p>分配在静态内存和动态内存中的对象由编译器自动创建和销毁。</p><p>程序拥有内存池，称为自由空间或堆（heap）。用来存储动态分配的对象。</p><h2 id="12-1动态内存与智能指针"><a href="#12-1动态内存与智能指针" class="headerlink" title="12.1动态内存与智能指针"></a>12.1动态内存与智能指针</h2><p>动态内存的管理，一对运算符new、delete</p><p>动态内存的使用容易出问题：内存泄漏（没有释放内存）、引用非法内存的指针（提前释放）、二次delete</p><p>智能指针：负责自动释放所指对象</p><p>shared_ptr、unique_ptr、weak_prt <memory></p><h3 id="12-1-1-shared-ptr类"><a href="#12-1-1-shared-ptr类" class="headerlink" title="12.1.1 shared_ptr类"></a>12.1.1 shared_ptr类</h3><p>shared_ptr<string> p1;</p><p>默认初始化的智能指针保存着一个空指针</p><p><strong>make_shared<T> (args)//返回一个shared_ptr，指向一个动态分配的类型为T的对象</strong></p><p>shared_ptr<T>p(q)//p是q的拷贝，递增q中的计数器</p><p>p = q//递减p的引用计数、递增q的引用计数</p><p>p.unique()//p.use_count()==1</p><p>p.use_count()//与p共享对象的智能指针数量</p><p>当指向一个对象最后一个shared_ptr呗毁坏掉，shared_ptr类会自动销毁此对象。通过析构函数。</p><p>shared_ptr保存在局部变量中，在代码块结束后被释放掉。但是，如果返回p，引用计数增加，p离开作用域不会被释放掉。</p><p>分配的资源与对象的生存期一致。分配的资源与对象的生存期相独立。（共享相同的底层元素）</p><p><strong>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</strong></p><h3 id="12-1-2-直接内存管理"><a href="#12-1-2-直接内存管理" class="headerlink" title="12.1.2 直接内存管理"></a>12.1.2 直接内存管理</h3><p>在自由空间分配的内存是无名的，new无法为其分配的对象命名，而是返回一个指向该对象的指针。</p><p><strong>new:构造一个对象，返回指向该对象的指针。</strong></p><p>一个动态分配的const对象必须进行初始化。new返回的指针是一个指向const的指针。</p><p><strong>const</strong> int <em>pci = new *</em>const** int(1024);</p><p>内存耗尽，抛出异常bad_alloc。改变new的方式阻止它抛出异常。定位new(placement new)，允许我们向new传递额外的参数。</p><p>int <em>p = new *</em>(nothrow)** int;</p><p><strong>delete:销毁该给定指针指向的对象，释放对应的内存。</strong></p><p>释放空指针不会产生错误，但是释放已经释放过的指针会产生错误。</p><p>坚持使用智能指针避免动态内存使用的常见问题。</p><p>delete之后，指针变成空悬指针(dangling pointer)。==指针离开作用域前释放掉关联的内存。==delete后，将nullptr赋予指针。</p><h3 id="12-1-3-shared-ptr和new结合使用"><a href="#12-1-3-shared-ptr和new结合使用" class="headerlink" title="12.1.3 shared_ptr和new结合使用"></a>12.1.3 shared_ptr和new结合使用</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>11关联容器</title>
    <link href="/2020/07/05/11%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <url>/2020/07/05/11%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="第11章关联容器"><a href="#第11章关联容器" class="headerlink" title="第11章关联容器"></a>第11章关联容器</h1><p>associative-container</p><p>关联容器支持高效的关键字的查找和访问。</p><p>两个主要的关联容器<strong>类型</strong>：set和map。</p><p>允许重复关键字multi_</p><p>不保持关键字顺序unordered_(哈希函数组织的)</p><p>标准库提供8个关联容器。头文件<map> <set> <unordered_map> <unordered_set></p><h2 id="11-1使用关联容器"><a href="#11-1使用关联容器" class="headerlink" title="11.1使用关联容器"></a>11.1使用关联容器</h2><p>map使用[key]。如果key没有在map中，下标运算符会创建一个新元素。</p><p>set 使用下标运算符访问。判断是否存在元素Key。if(set.find(key)==set.end())</p><h2 id="11-2关联容器概述"><a href="#11-2关联容器概述" class="headerlink" title="11.2关联容器概述"></a>11.2关联容器概述</h2><p>关联容器的迭代器都是双向的。</p><h3 id="11-2-1定义关联容器"><a href="#11-2-1定义关联容器" class="headerlink" title="11.2.1定义关联容器"></a>11.2.1定义关联容器</h3><p>空容器</p><p>列表初始化</p><pre><code class="hljs cpp"><span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>&gt; exclude = &#123;<span class="hljs-string">"the"</span>,<span class="hljs-string">"big"</span>,<span class="hljs-string">"band"</span>&#125;;<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt; ages=&#123;&#123;<span class="hljs-string">"Alice"</span>,<span class="hljs-number">18</span>&#125;,&#123;<span class="hljs-string">"Bob"</span>,<span class="hljs-number">24</span>&#125;&#125;;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
