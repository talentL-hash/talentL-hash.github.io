<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo博客/hexo博客命令</title>
    <link href="/2021/04/16/hexo%E5%8D%9A%E5%AE%A2/hexo%E5%8D%9A%E5%AE%A2%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/04/16/hexo%E5%8D%9A%E5%AE%A2/hexo%E5%8D%9A%E5%AE%A2%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs verilog"># hexo cleanhexo g# <span class="hljs-keyword">generate</span># hexo s#<span class="hljs-keyword">local</span> serverhexo d#remote deploy</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hyperledger Fabric/1.set up and begin</title>
    <link href="/2021/04/16/Hyperledger%20Fabric/1.set%20up%20and%20begin/"/>
    <url>/2021/04/16/Hyperledger%20Fabric/1.set%20up%20and%20begin/</url>
    
    <content type="html"><![CDATA[<p>I have chose <code>go mod</code> to manage my package dependence. My project name is <code>ASRchain</code>.</p><h1 id="Step-1-init"><a href="#Step-1-init" class="headerlink" title="Step 1 init"></a>Step 1 init</h1><p>First, I make a directory called <code>ASRchain</code> and then init in it use the command below:</p><pre><code class="hljs shell"><span class="hljs-meta">ASRchain$</span><span class="bash"> go mod init ASRchain</span></code></pre><h1 id="Step-2-Set-proxy-and-GO111MODULE"><a href="#Step-2-Set-proxy-and-GO111MODULE" class="headerlink" title="Step 2 Set proxy and GO111MODULE"></a>Step 2 Set proxy and GO111MODULE</h1><pre><code class="hljs vim">ASRchain$ <span class="hljs-keyword">go</span> env -<span class="hljs-keyword">w</span> GOPROXY=http<span class="hljs-variable">s:</span>//goproxy.<span class="hljs-keyword">cn</span>,directASRchain$ <span class="hljs-keyword">go</span> env -<span class="hljs-keyword">w</span> GO111MODULE=<span class="hljs-keyword">on</span></code></pre><blockquote><p>GO111MODULE 有三个值：off, on和auto（默认值）。</p><p>GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。<br> GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。<br> GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：</p><pre><code class="hljs go">当前目录在GOPATH/src之外且该目录包含<span class="hljs-keyword">go</span>.mod文件当前文件在包含<span class="hljs-keyword">go</span>.mod文件的目录下面。</code></pre><p>当modules功能启用时，依赖包的存放位置变更为$GOPATH/pkg，允许同一个package多个版本并存，且多个项目可以共享缓存的 module</p><p><a href="https://www.jianshu.com/p/760c97ff644c" target="_blank" rel="noopener">https://www.jianshu.com/p/760c97ff644c</a> (go mod使用)</p></blockquote><h1 id="Step-3-set-GOPATH"><a href="#Step-3-set-GOPATH" class="headerlink" title="Step 3 set GOPATH"></a>Step 3 set GOPATH</h1><p>This is a tricky one. </p><p><code>$GOPATH/pkg</code> is where go mod keep all packages and <code>$GOPATH</code> directory should contain no <code>src/</code> directory in it. Or you will get <code>$GOPATH/go.mod exists but should not</code> error.</p><p><a href="https://github.com/golang/go/issues/38896" target="_blank" rel="noopener">https://github.com/golang/go/issues/38896</a></p><ul><li>vim /etc/profile and add <ul><li>export GOPATH=/mnt/path/to/store</li></ul></li><li>source /etc/profile</li></ul><h1 id="Step-4-play-around"><a href="#Step-4-play-around" class="headerlink" title="Step 4 play around"></a>Step 4 play around</h1><p>You can go into any directory below the project.And run <code>go test</code>.</p><p>In the test file (named <code>xxx_test.go</code>), you can use <code>&quot;ASRchain/src/common&quot;</code> to import other local package.</p><p>Finally, you can get a directory tree like this.</p><img src="/2021/04/16/Hyperledger%20Fabric/1.set%20up%20and%20begin/tree.png" srcset="/img/loading.gif" class title="ASRchain dictionary tree"><p><img src="/2021/04/16/Hyperledger%20Fabric/1.set%20up%20and%20begin/tree.png" srcset="/img/loading.gif" alt="ASRchain dictionary tree"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hyperledger Fabric/应用开发</title>
    <link href="/2021/01/18/Hyperledger%20Fabric/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    <url>/2021/01/18/Hyperledger%20Fabric/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>应用包括客户端应用程序和智能合约</p><p>账本中包含当前所有对象最新状态的世界状态和所有交易历史</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hyperledger Fabric/测试网络部署</title>
    <link href="/2021/01/15/Hyperledger%20Fabric/%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2/"/>
    <url>/2021/01/15/Hyperledger%20Fabric/%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>研究生毕设需要用到Hyperledger Fabric，最终目标是能够使用Fabric提供的API编写链码，设计系统架构，账本设计，事务设计，分片设计，编写监听程序，最终运行在真系统中。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hyperledger Fabric/fabric CA</title>
    <link href="/2020/11/06/Hyperledger%20Fabric/fabric%20CA/"/>
    <url>/2020/11/06/Hyperledger%20Fabric/fabric%20CA/</url>
    
    <content type="html"><![CDATA[<p>fabric CA提供的主要功能：</p><ul><li>注册身份，或者连接到LDAP作为用户注册</li><li>签发注册证明书（ECerts）</li><li>证书续订和撤销</li></ul><p>fabric CA由服务器（server）和客户端（client）组成。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hyperledger Fabric/将智能合约应用到信道上</title>
    <link href="/2020/09/28/Hyperledger%20Fabric/%E5%B0%86%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BA%94%E7%94%A8%E5%88%B0%E4%BF%A1%E9%81%93%E4%B8%8A/"/>
    <url>/2020/09/28/Hyperledger%20Fabric/%E5%B0%86%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BA%94%E7%94%A8%E5%88%B0%E4%BF%A1%E9%81%93%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>端用户通过调用智能合约与区块链账本交互。在Hyperledger Fabric中，智能合约以包的形式进行部署，也被称作链码。需要验证交易和查询账本的组织需要在peer上安装链码。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hyperledger Fabric/Hyperledger Fabric</title>
    <link href="/2020/09/20/Hyperledger%20Fabric/Hyperledger%20Fabric/"/>
    <url>/2020/09/20/Hyperledger%20Fabric/Hyperledger%20Fabric/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>区块链是一个由分布式网络节点维护的不可篡改账本,每个节点使用共识协议维护账本的副本，账本以链式区块的形式存储,每个块通过哈希和之前的块相连.</p><p>企业业务</p><ul><li>参与者需要获得认证/许可</li><li>吞吐量性能、交易确认延迟</li><li>数据隐私和机密性</li></ul><h2 id="Hyperledger-Fabric的特性"><a href="#Hyperledger-Fabric的特性" class="headerlink" title="Hyperledger Fabric的特性"></a>Hyperledger Fabric的特性</h2><ul><li>模块化、可配置</li><li>通用语言编写智能合约</li><li>基于许可</li><li>可插拔的共识协议</li><li>不使用原生加密货币</li><li>性能较好</li><li>隐私保护</li></ul><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块化组件：</p><ul><li>排序服务：对交易顺序达成共识</li><li>成员服务提供者：网络实体和加密身份相关联</li><li>P2P gossip服务：将区块信息发送给其他节点</li><li>智能合约（链码）：隔离运行在容器环境当中，不能直接访问账本状态</li><li>账本可以支持多种DBMS</li><li>背书和验证策略</li></ul><h2 id="许可区块链和非许可区块链"><a href="#许可区块链和非许可区块链" class="headerlink" title="许可区块链和非许可区块链"></a>许可区块链和非许可区块链</h2><p>非许可区块链：需要用经济激励抵消基于Pow的拜占庭容错的成本</p><p>许可区块链：可以使用传统的崩溃容错CFT和拜占庭容错BFT降低了通过智能合约引入恶意代码的风险</p><p>架构：</p><ol><li>大多数具有智能合约能力的区块链：顺序执行架构（排序-执行）</li><li>Fabric的架构（执行-排序-验证）并行执行提高效率和规模</li></ol><h2 id="隐私和保密性"><a href="#隐私和保密性" class="headerlink" title="隐私和保密性"></a>隐私和保密性</h2><p>通过通道架构和私有数据特性实现保密</p><p>参与到通道的节点才有权访问智能合约和交易数据</p><h2 id="可插拔共识"><a href="#可插拔共识" class="headerlink" title="可插拔共识"></a>可插拔共识</h2><p>排序服务</p><p>Raft协议的CTF排序服务</p><p>一个Fabric网络当中可以支持多种排序服务</p><h2 id="性能和可扩展性"><a href="#性能和可扩展性" class="headerlink" title="性能和可扩展性"></a>性能和可扩展性</h2><p>Hyperledger Caliper基准测试框架</p><h1 id="区块链网络"><a href="#区块链网络" class="headerlink" title="区块链网络"></a>区块链网络</h1><p>为应用程序提供账本和智能合约服务的技术基础设施。</p><h2 id="构建区块链网络"><a href="#构建区块链网络" class="headerlink" title="构建区块链网络"></a>构建区块链网络</h2><p>定义网络N：排序服务O，网络配置NC，组织R，CA（向组织的网络节点和管理者分配身份信息）</p><p><img src="C:%5CUsers%5Ctalent%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200920200733725.png" srcset="/img/loading.gif" alt="image-20200920200733725"></p><h2 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h2><p>在一个网络当中，不同的组织通常使用不同的CA。</p><p>将证书同成员组织进行匹配是通过成员服务提供者MSP的结构实现的。</p><h2 id="添加网络管理员"><a href="#添加网络管理员" class="headerlink" title="添加网络管理员"></a>添加网络管理员</h2><p><img src="C:%5CUsers%5Ctalent%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200920202414548.png" srcset="/img/loading.gif" alt="image-20200920202414548"></p><h2 id="定义联盟"><a href="#定义联盟" class="headerlink" title="定义联盟"></a>定义联盟</h2><p><img src="C:%5CUsers%5Ctalent%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200920202739093.png" srcset="/img/loading.gif" alt="image-20200920202739093"></p><p>包含组织R1和R2的联盟X1。联盟中的组织共享彼此的交易。</p><h2 id="为联盟创建通道"><a href="#为联盟创建通道" class="headerlink" title="为联盟创建通道"></a>为联盟创建通道</h2><p><img src="C:%5CUsers%5Ctalent%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200920202933386.png" srcset="/img/loading.gif" alt="image-20200920202933386"></p><p>通道C的通道配置为CC，配置由R1和R2共同管理，具有同等权利。</p><p>通道代表将来进行连接的可能性。</p><p>通道为联盟成员之间进行私有通信和私有通道提供了机制。</p><p>系统通道：排序服务使用的通道</p><p>应用通道：常规通道</p><h2 id="节点和账本"><a href="#节点和账本" class="headerlink" title="节点和账本"></a>节点和账本</h2><p><img src="C:%5CUsers%5Ctalent%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200920204414468.png" srcset="/img/loading.gif" alt="image-20200920204414468"></p><p>Peer节点P1，物理上存储账本L1的副本。</p><p>账本L1，物理被存在P1上，逻辑被存在C1上。</p><h2 id="客户端应用和智能合约"><a href="#客户端应用和智能合约" class="headerlink" title="客户端应用和智能合约"></a>客户端应用和智能合约</h2><p><img src="C:%5CUsers%5Ctalent%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200920205713408.png" srcset="/img/loading.gif" alt="image-20200920205713408"></p><p>客户端应用A1、智能合约S5</p><p>客户端应用A1通过在Peer节点P1上的智能合约S5访问账本。</p><p>智能合约被用来帮助生成分发到网络中各个节点的交易。</p><p>智能合约必须被<strong>安装</strong>（物理上，存储到Peer节点上），必须<strong>在通道被定义</strong>（逻辑上，定义智能合约的接口到通道）</p><h3 id="安装链码包"><a href="#安装链码包" class="headerlink" title="安装链码包"></a>安装链码包</h3><h3 id="定义链码"><a href="#定义链码" class="headerlink" title="定义链码"></a>定义链码</h3><h3 id="背书策略"><a href="#背书策略" class="headerlink" title="背书策略"></a>背书策略</h3><p>背书策略：交易被接收并存储在账本副本之前，哪些组织必须同意此交易</p><h3 id="调用智合约"><a href="#调用智合约" class="headerlink" title="调用智合约"></a>调用智合约</h3><p>客户端应用是通过发送交易提案给智能合约背书策略所指定的 Peer 的节点方式来调用智能合约的。</p><p>经过背书的交易（交易响应+交易提案）</p><h2 id="完成网络"><a href="#完成网络" class="headerlink" title="完成网络"></a>完成网络</h2><h3 id="生成并接受交易"><a href="#生成并接受交易" class="headerlink" title="生成并接受交易"></a>生成并接受交易</h3><p>当网络的规模比较庞大时，会存在许多Peer节点没有存储智能合约。Peer节点可以通过通道获取智能合约的接口。</p><p>所有的Peer节点都可以进行验证、接受或拒绝交易存储在账本当中，但是只有存储智能合约的节点能够参与背书的流程。</p><h3 id="Peer节点的类型"><a href="#Peer节点的类型" class="headerlink" title="Peer节点的类型"></a>Peer节点的类型</h3><p>提交节点：通道中的每一个Peer节点</p><p>背书节点：安装了智能合约的节点</p><h1 id="测试网络安装"><a href="#测试网络安装" class="headerlink" title="测试网络安装"></a>测试网络安装</h1><p>安装docker</p><p>安装curl</p><p>clone fabric-samples</p><p>cd fabric-samples</p><p>git tag检查标签</p><p>git checkout -b v2.1.0</p><p>使用bootstrap.sh脚本下载二进制文件、配置文件、拉取镜像，脚本下载地址<a href="https://github.com/hyperledger/fabric/blob/master/scripts，选择标签对应的分支，下载脚本，运行脚本。" target="_blank" rel="noopener">https://github.com/hyperledger/fabric/blob/master/scripts，选择标签对应的分支，下载脚本，运行脚本。</a></p><h2 id="安装测试网络"><a href="#安装测试网络" class="headerlink" title="安装测试网络"></a>安装测试网络</h2><p>/fabric-samples/test-network# ./network.sh up，结果如下：</p><pre><code class="hljs shell">Creating network "net_test" with the default driverCreating volume "net_orderer.example.com" with default driverCreating volume "net_peer0.org1.example.com" with default driverCreating volume "net_peer0.org2.example.com" with default driverCreating orderer.example.com    ... doneCreating peer0.org2.example.com ... doneCreating peer0.org1.example.com ... doneCONTAINER ID        IMAGE                               COMMAND             CREATED             STATUS                  PORTS                              NAMES8d0c74b9d6af        hyperledger/fabric-orderer:latest   "orderer"           4 seconds ago       Up Less than a second   0.0.0.0:7050-&gt;7050/tcp             orderer.example.comea1cf82b5b99        hyperledger/fabric-peer:latest      "peer node start"   4 seconds ago       Up Less than a second   0.0.0.0:7051-&gt;7051/tcp             peer0.org1.example.comcd8d9b23cb56        hyperledger/fabric-peer:latest      "peer node start"   4 seconds ago       Up 1 second             7051/tcp, 0.0.0.0:9051-&gt;9051/tcp   peer0.org2.example.com</code></pre><p>创建两个对等节点peer0.org2.example.com、peer0.org1.example.com（分别属于不同的组织），一个排序节点orderer.example.com。</p><p>对等节点：</p><ul><li>存储区块链账本，并在交易之前进行验证</li><li>运行管理区块链账本的智能合约上的业务逻辑</li></ul><p>排序节点：</p><ul><li>从客户收到交易，就交易顺序达成共识，添加区块</li><li>将区块分配给添加这些区块到账本的对等节点</li></ul><h2 id="建立通道"><a href="#建立通道" class="headerlink" title="建立通道"></a>建立通道</h2><p>createChannel</p><pre><code class="hljs jboss-cli"><span class="hljs-string">./network.sh</span> createChannel<span class="hljs-comment">#默认名称mychannel</span><span class="hljs-string">/network.sh</span> createChannel -c channel1<span class="hljs-comment">#自定义名称</span><span class="hljs-string">./network.sh</span> up createChannel<span class="hljs-comment">#创建网络并创建通道</span></code></pre><h2 id="启动链码"><a href="#启动链码" class="headerlink" title="启动链码"></a>启动链码</h2><pre><code class="hljs jboss-cli"><span class="hljs-string">./network.sh</span> <span class="hljs-keyword">deploy</span>CC<span class="hljs-comment">#默认mychannel通道</span></code></pre><p>报错：failed to nromalize chaincode path: ‘go list’</p><p>原因：go依赖包长时间无响应</p><p>解决办法：使用镜像</p><p>go env -w GO111MODULE=on</p><p>go env -w GOPROXY=<a href="https://goproxy.cn,direcr" target="_blank" rel="noopener">https://goproxy.cn,direcr</a></p><p>报错：chaincode install failed with status: 500 - failed to invoke backing implement of  ‘InstallChaincode’</p><p>原因：go版本过低，可以使用go version查看版本，使用go env查看go的安装路径GOROOT</p><p>解决办法：更新go版本，（1.13-&gt;1.15），删除旧版本路径上的文件夹，在官网上下载最新的go安装包，解压，到相同文件夹</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工作复习/C++/C++语言基础</title>
    <link href="/2020/08/02/%E5%B7%A5%E4%BD%9C%E5%A4%8D%E4%B9%A0/C++/C++%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/08/02/%E5%B7%A5%E4%BD%9C%E5%A4%8D%E4%B9%A0/C++/C++%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h1 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h1><p>设计思想上看：</p><ul><li>C是面向过程的结构化语言，C++是面向对象的语言</li></ul><p>语法上看：</p><ul><li>C++具有封装、继承、多态</li><li>C++相比C，多了许多安全类型的功能，比如强制类型转换</li><li>C++支持范式编程，比如模板类、函数模板等</li></ul><h2 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h2><p>封装：将数据和操作数据的方法有机结合，隐藏对象属性和实现细节，仅提供对外接口与对象进行交互。</p><p>继承：基类、继承方式、派生类<a href="https://blog.csdn.net/studyhardi/article/details/90744785" target="_blank" rel="noopener">https://blog.csdn.net/studyhardi/article/details/90744785</a></p><ul><li>保持原有特性的基础上进行扩展，增加功能，产生新的类（派生类）。类设计层次复用</li><li>三种继承方式：private、protected、public</li><li>class Student: public Person，class的默认继承方式为private，struct默认继承方式为public</li><li>继承基类</li><li>友元关系不能继承，基类友元不能访问子类的私有和保护成员</li><li>基类定义了static成员，无论派生多少子类，只有一个static成员实例，基类和子类共享一个成员</li><li></li></ul><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><h2 id="范式编程"><a href="#范式编程" class="headerlink" title="范式编程"></a>范式编程</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工作复习/BGP</title>
    <link href="/2020/07/24/%E5%B7%A5%E4%BD%9C%E5%A4%8D%E4%B9%A0/BGP/"/>
    <url>/2020/07/24/%E5%B7%A5%E4%BD%9C%E5%A4%8D%E4%B9%A0/BGP/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工作复习/Raft分布式一致性算法</title>
    <link href="/2020/07/07/%E5%B7%A5%E4%BD%9C%E5%A4%8D%E4%B9%A0/Raft%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/07/%E5%B7%A5%E4%BD%9C%E5%A4%8D%E4%B9%A0/Raft%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><p><a href="https://www.cnblogs.com/mokafamily/p/11303534.html" target="_blank" rel="noopener">https://www.cnblogs.com/mokafamily/p/11303534.html</a></p><p><a href="https://www.jianshu.com/p/ee7646c0f4cf#" target="_blank" rel="noopener">https://www.jianshu.com/p/ee7646c0f4cf#</a></p><p>分布式系统中各个部分保持数据一致，就是分布式一致性问题。</p><h1 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h1><p>CAP定理证明了分布式系统只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p><ul><li>一致性（Consistency）：指的就是整个集群的所有节点数据保持一致</li><li>可用性（Availability）：在数据同步过程中，集群是否是可用状态</li><li>分区容忍性（Partition tolerance）：是否能够容忍网络分区的发生</li></ul><p>在所有分布式系统中，P几乎都是不可抛弃的，选择只剩下AP和CP。</p><p>但是，如果我们有一个single master+multiple slaves的mysql数据库，当leader不可用时，用户则不能进行写入，也就丧失了A属性，但由于MySQL是通过binlog异步同步数据库的，用户也有可能读到的是旧数据，所以说该系统也许既不满足A也不满足C，仅仅满足了P属性。</p><h1 id="一致性级别"><a href="#一致性级别" class="headerlink" title="一致性级别"></a>一致性级别</h1><h2 id="强一致性（线性一致性）"><a href="#强一致性（线性一致性）" class="headerlink" title="强一致性（线性一致性）"></a>强一致性（线性一致性）</h2><p>任何时间访问任何存储节点都是最新的值，客户端操作一个强一致性的数据库，感觉自己在操作一个单机数据库。</p><h2 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h2><p>不对一致性进行保证。某些系统对一致性的要求不高，从而舍弃强一致性策略带来的性能与可用性消耗。</p><h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>可理解为弱一致性的一种，在写入后仍可能得到旧值。</p><p>最终一致性的核心是保证同步的请求不会丢失，在请求到达时，节点的状态变为最新的状态，而不考虑请求传输时的不一致窗口。</p><h1 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h1><p>raft是强一致性算法。强一致性强调的是强一致性读，既不会读到过期的结果。但并不要求将每个写请求复写到集群中的每个节点上。</p><h2 id="目标：复制的Log"><a href="#目标：复制的Log" class="headerlink" title="目标：复制的Log"></a>目标：复制的Log</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-decc26c5a3f6da23.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>Raft总体目标是将Log完全一致地复制到集群中的所有机器上。</p><p>State Machine是一个具体的应用程序，能接收请求，输出结果。不是所有command都被执行，只有被“安全地复制”的command才允许执行（复制持久化，复制到集群中的大多数machine）。不同server上的相同的State Machine按照完全一样的顺序执行Log中的相同command，必定输出相同的结果。</p><p>Consensus Module一致性模块，管理Log，确保被合理地复制，并决定什么时候将Log中的command提交给State Machine执行。</p><p>允许网络中断、消息丢失、消息延迟、消息传递乱序、网络分化等，但是不包括Byzantine failures（拜占庭将军问题，指的是恶意篡改数据这类行为）。</p><h2 id="保持一致性的方法"><a href="#保持一致性的方法" class="headerlink" title="保持一致性的方法"></a>保持一致性的方法</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-354db659cba08d14.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>实现一致性算法有两种可能方式：</p><p>1）第一种叫对称式，或无leader：这种方式中所有server的角色完全一样，权利也一样，在任意时刻的行为也基本一样，所有server都是对等的；客户端可以请求任意一台server，将command写入log中，并复制到其他server（其实就是完全平等制、无政府主义）；</p><p>2）第二种叫非对称式，或leader-based：在任意时间各个server都是不平等的，某个时刻只有一个server是leader，管理集群中的所有操作；其他server都是被统治的，只能简单按照leader的旨意干活；在这类系统中，客户端只能与leader通信，也只有leader能与其他server交流（其实就是专制独裁统治，只有一个leader，可以为所欲为，其他所有人都必须听命于leader，只有leader能对外交流）；</p><p>raft采用的就是第二种leader-based的方式，并且把一致性问题分解为两个不同问题：一是在有leader的情况下集群如何正常运作，二是leader挂掉之后如何选举更换leader。raft采用的这种leader-based方式的优势是使得正常运作过程非常简单，因为你不需要担心多个leader同时指挥导致的冲突，记住只有一个leader，leader可以为所欲为；raft算法的所有复杂性其实都来自于leader变更，这是因为旧leader忽然挂掉，可能导致整个系统处于不一致的状态，新leader上任后必须收拾残局。（后面大家会有切身体会，raft正常的运行过程非常简单，但是leader变更过程非常复杂）</p><h2 id="Raft总体"><a href="#Raft总体" class="headerlink" title="Raft总体"></a>Raft总体</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-c3ecc214a4eaf58b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>raft讲解提纲，共6个部分：</p><p>1、leader选举：如何从多个server中挑选一台作为leader；当leader挂掉之后，如何感知到，并挑选出新的leader来替换旧leader；</p><p>2、正常运行（最基本的log复制过程）：leader从客户端收到请求后如何将log复制到其他机器；这其实是整个raft算法中最简单的部分；</p><p>3、leader变更过程中的安全性和一致性：leader变更是raft中最难的，也是最关键的；首先会讲下safety到底意味着什么，以及如何保证safety；接着讲新leader上任后如何处理log，使得整个系统恢复一致性状态；</p><p>4、neutralize 旧leader：这是leader变更中的另一个问题，就是旧leader并没有真的死掉，死灰复燃，重新恢复之后，我们该如何处理；</p><p>5、客户端交互：客户端如何与整个系统交互？关键点是请求过程中server挂掉了client怎么办？如何实现linearizable semantics（线性化语义），即每个客户端命令只能执行一次（once and exactly once，其实就是防止出现多次执行出问题，类似于幂等性概念）;</p><p>6、配置变更：如何在集群中新增、或删除机器？</p><h2 id="Server状态分类（三种）"><a href="#Server状态分类（三种）" class="headerlink" title="Server状态分类（三种）"></a>Server状态分类（三种）</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-38c87cba8925b8dc.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img">Server的三种状态Follower、Candidate、Leader。</p><p>正常情况下的集群状态应该是：1个leader，其他所有都是follower。</p><h2 id="任期Terms"><a href="#任期Terms" class="headerlink" title="任期Terms"></a>任期Terms</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-18e8a85eccf45f03.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>时间被划分成一个个的term（这里的term，还有zookeeper中的epoch，都是同一个意思，指的就是任期、时期、年代；指的是某一个leader的统治时期），每个term都有一个number，这个number必须单向递增且从未被用过。</p><p>旧leader一挂，就进入新term；新term一开始必须进行选举，选举成功则leader登基开始执政；选举不成功则立即进入新的term，开始新的一轮。</p><p>current term value用来识别过期信息，比如某个认为当前term是2的server跟另外一个认为当前term是3的server进行通讯，我们就知道前一个server的信息是过时的。其理念类似于抢夺式锁，用于解决不同term信息的冲突。总是采用最新的term信息。</p><h2 id="Raft协议总结（各个server之间交互）"><a href="#Raft协议总结（各个server之间交互）" class="headerlink" title="Raft协议总结（各个server之间交互）"></a>Raft协议总结（各个server之间交互）</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-ad285652dcf26229.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>简要说下图中展示的几点：</p><p>1）各个角色的行为过程：参见follower、candidate和leader下面的描述；</p><p>2）需要持久化到磁盘上的状态数据（Persistent Satate）、log中每条数据的格式；</p><p>3）各个server之间如何交互：raft中所有server之间的通信都是RPC调用，并且只有两种类型的RPC调用：第一种是RequestVote，用于选举leader；第二种是AppendEntries，用于normal operations中leader向其他机器复制log；</p><h2 id="心跳Heartbeats和Timeouts"><a href="#心跳Heartbeats和Timeouts" class="headerlink" title="心跳Heartbeats和Timeouts"></a>心跳Heartbeats和Timeouts</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-1ccec03fb937fb70.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>刚开始没有follower，所有server等待elecctionTimeout进行新一轮选举。</p><p>leader保持自己的权威，必须不断发心跳。</p><h2 id="选举基础和特性"><a href="#选举基础和特性" class="headerlink" title="选举基础和特性"></a>选举基础和特性</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-1b9ff43d36e72a02.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p><img src="https://upload-images.jianshu.io/upload_images/4788617-4bbf50f75cbfb5d0.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>选举过程中必须保证两大特性（图中cont’d是continued的意思，表示接着上一个slide继续）：</p><p>1）safety：安全性，意思是说在任意一个给定的term内，最多只允许一个server获胜成为leader；为了保证这一点，需要两个条件：</p><p>a.任意一个server在一个term内只能投出一票；一旦已经投给了一个candidate，它必须拒绝其他candidate的投票请求；其实server根本不在意把票投给谁，它只会把票投给最先到请求到它的candidate；为了保证这一点，必须把投票信息持久保存到磁盘上，这样可以保证即使该server投完票后宕机，稍后又立即重启了，也不会在同一个term内给第二个candidate投票了。</p><p>b.只有获得大多数投票才能获胜</p><p>结合a,b：一个server在同一个term内只能投一票，一个candidate为了获胜必须获得过半投票，显而易见，在同一个term内不可能有两个candidate同时当选；一旦有candidate获得大多数投票，其他candidate不可能再获得过半投票了；不同term内，当然可以有不同的candidate获胜，但同一个term内，只可能有一个获胜；</p><p>2）liveness：为了保证系统能向前运行，我们要确保不能一直都是无leader状态，必须要能最终选出一个leader；</p><p>问题的关键就是我们要确保不要总是出现splited vote（投票分散），即我们不要让多个candidate总是同时开始竞选，这很容易使投票分散；同时开始竞选，然后投票分散，无法形成大多数一直，然后等待超时，然后再同时开始竞选，这成了一个恶性循环；</p><p>raft的解决办法很简单，即使得election timeout分散开来，不要让所有server的election timeout都相同，而是在T到2T之间随机选择超时时间（T就是election timeout，这个值通常要比系统中最快的机器的超时时间短）；每个server每次都用随机方法计算出超时时间；通过把timeout分散开来，每次取值不一样，这样不太可能还会出现两个server同时超时然后同时开始竞选的情况；总有机器最先超时，然后有充足时间在其他server也超时之前发起投票、赢得选举；这种办法在T远大于broadcast time（传播时间，指的是server发起投票、收到投票所花时间）的情况下效果尤其明显；</p><p>（点评：<strong>safety其实是保证系统一致性运行的最低要求</strong>，其核心是cannot do something bad，即不能干坏事、不能做错事；<strong>liveness其实是更高要求，意味着不能只是不干坏事，也不能一直不干事</strong>，you must do something good，即必须使得整个系统能良好运转下去；因为如果一直处于无leader状态，其实系统是不能对外提供服务的；liveness本意就是活性、生存性，在java并发编程中也有该概念，定义如A concurrent application’s ability to execute in a timely manner is known as its liveness.总结来说，liveness说的是应用程序运行及时性的能力，核心在于要“及时”执行，即在通常认为的合理时间内要能执行。）</p><h2 id="Log结构"><a href="#Log结构" class="headerlink" title="Log结构"></a>Log结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-a5f095511d333f30.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>提醒一点：过半即是提交，这个定义并不精确，后面会稍作修改。（现在你可以暂时认为committed就是指的过半，后面会看到还会加一点额外限制条件，用于解决server变化时候的log一致性问题）</p><h2 id="正常操作"><a href="#正常操作" class="headerlink" title="正常操作"></a>正常操作</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-3eaf041a7415cdac.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>client请求leader-》leader在本地log中写入entry-》leader向所有followers广播entry-》leader收到过半响应，认为已提交-》leader执行对应命令，返回结果-》同时leader向所有followers广播提交信息-》其他follower获知已提交则也执行对应命令。</p><p>最终所有server都会执行该请求，但client不会等到所有server执行完，只需等到leader执行完即可；但执行是有条件的，即log必须复制到过半server上才能开始执行；如果给定时间内仍复制不到过半server，则本次请求失败，客户端必须发起重试；</p><p>注意：有请求进来，leader只需等到大多数机器有响应即可执行命令并返回结果；leader不需要等待所有机器有响应才执行命令，但是leader需要不断发请求给所有机器，以确保最终所有机器都有响应，并执行相同的命令；这是不矛盾的；</p><h2 id="Log一致性"><a href="#Log一致性" class="headerlink" title="Log一致性"></a>Log一致性</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-6a0f5466e72fa39d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>index和term组合起来唯一标识从开始到index位置的整条log</p><p>只要entry的index和term相同，则其command一定相同</p><h2 id="AppendTntries一致性检查"><a href="#AppendTntries一致性检查" class="headerlink" title="AppendTntries一致性检查"></a>AppendTntries一致性检查</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-ba1715b5e6829473.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>当leader向follower发送AppendEntries RPC请求的时候，除了要发送新的log entry之外，还要额外带上两个值：即新entry的前一个entry的index和term；</p><p>一旦某个follower接收了某条entry，则意味着这个follower的log中从起始位置到这条entry为止的所有entries都跟leader的完全匹配；</p><h2 id="Leader更换"><a href="#Leader更换" class="headerlink" title="Leader更换"></a>Leader更换</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-94834154b4ec024e.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>图中S2成为term7时期的leader后，如果能够与其他所有server通信，那它最终要保证其他所有server的log与它的log相同，这就意味着与之有冲突的log entry必须被清除；后续会详细讲解leader如何进行clean up使得followers的log与之相同；特别强调一下correctness和safety，我们怎样才能确保系统正常运行，确保不丢失重要信息呢？如我们刚才为了保证一致性，丢弃了一些log，我们怎样做才是安全的呢？</p><h2 id="Safety要求"><a href="#Safety要求" class="headerlink" title="Safety要求"></a>Safety要求</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-6ef77d33c8979a2b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>某个entry已被提交 -&gt; 这条entry必定在后续leader中存在</p><p>为了实现这个安全性目标，我们必须从两方面修正raft算法：</p><p>a. 对leader election增加约束条件：如果某个server的log中缺少某个已提交entry，则不允许这个server当leader；</p><p>b. 必须改变对committed的定义：前面说的已过半即是committed，这是不够的；有时候我们必须延迟committed，直到我们认为安全了才能committed；所谓的安全，就是说我们认为能够保证后续leader有这条entry；</p><p>约束a是排除了某些server当leader，即不含有已提交entry的server不允许当leader；显而易见，只有约束a是不够的，因为a说的只是最低安全性条件，照此条件，有可能一个leader都选不出来；而b是对committed条件的加强，意味着对committed施加更严苛的条件，也意味着给更多server成为leader的机会，即能够保证最终能选出leader；后续会有相应case</p><h2 id="选取最好的Leader"><a href="#选取最好的Leader" class="headerlink" title="选取最好的Leader"></a>选取最好的Leader</h2><p><img src="https://upload-images.jianshu.io/upload_images/4788617-e5502e3643d3643d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>server3宕机，此时不能确定entry5是否committed，因为无法与server3通信。</p><p>挑选最有可能含有所有已提交entry的server做leader，即挑选the best leader! </p><p><img src="https://upload-images.jianshu.io/upload_images/4788617-6fb28858a1ebff5d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p><img src="https://upload-images.jianshu.io/upload_images/4788617-29c121746e7e7ece.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" srcset="/img/loading.gif" alt="img"></p><p>​    </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工作复习/一致性哈希算法</title>
    <link href="/2020/07/07/%E5%B7%A5%E4%BD%9C%E5%A4%8D%E4%B9%A0/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/07/%E5%B7%A5%E4%BD%9C%E5%A4%8D%E4%B9%A0/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>一致性哈希算法</p><h1 id="分布式缓存问题"><a href="#分布式缓存问题" class="headerlink" title="分布式缓存问题"></a>分布式缓存问题</h1><p>随着访问的流量加大，直接访问数据库的方式无法满足需求。这时可以采用缓存机制。</p><p>最简单的策略时每次访问访问数据库的请求被随机发送给一个缓存服务器。但是这样的策略存在很大的缺陷。同一个key的数据可能会存储到多个缓存服务器上，造成冗余，也使得缓存的效率降低。</p><p>为了使同一个key的访问被发送到同一个缓存服务器上，可以使用哈希取模的方式对key进行处理。h=Hash(key)%N。但是，如果出现服务器宕机或者需要扩展机器时，需要重新进行服务器编号，大量的key会被重定位到不同的服务器上，导致大量的缓存不命中。</p><p>总结来说，使用哈希取模的方式分配key的缓存容错性和扩展性都不好。</p><p>一个良好的分布式哈希方案应该具有良好的单调性，即服务节点的增减不会造成大量哈希重定位。一致性哈希算法就是这样一种哈希方案。</p><h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><p>一致性哈希算法将整个哈希地址组织成一个虚拟的圆环。</p><p>将服务器使用哈希函数计算在环上的地址，可以使用服务器的ip地址或主机名作为关键字进行哈希。</p><p>如果存在N台服务器，则将整个环分成了N段。</p><p>将数据key使用相同的函数H计算出哈希值h，h可以确定在环上的位置。从这个位置出发，顺时针“行走”，第一台遇到的服务器就是数据定位到的服务器。</p><p><img src="C:%5CUsers%5Ctalent%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200707184839428.png" srcset="/img/loading.gif" alt="image-20200707184839428"></p><p>容错性：如果此时server3宕机，只有D节点被重新定位到server2。</p><p><img src="C:%5CUsers%5Ctalent%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200707185121156.png" srcset="/img/loading.gif" alt="image-20200707185121156"></p><p>扩展性：如果增加server4，只需要B要重新定位到新的server4。</p><p>综上，一致性容错算法对于节点的增减只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p><h1 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h1><p>当环空间上的服务器分布不均时，会造成数据倾斜问题。</p><p>为了解决数据倾斜问题，一致性哈希算法引入虚拟节点机制，即每个计算结果位置都放置一个此服务节点。具体做法，可以在服务器ip或主机名的后面增加编号来实现。</p><p>数据定位算法不变，只是多了一步虚拟节点到实际节点的映射。虚拟节点的个数可以自行设置。</p><h1 id="Ketama算法"><a href="#Ketama算法" class="headerlink" title="Ketama算法"></a>Ketama算法</h1><p>Ketama算法具有广泛的应用，一些开源框架，譬如spymemcached、twemproxy等都内置了该算法的实现。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ primer/10.泛型算法</title>
    <link href="/2020/07/05/C++%20primer/10.%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/05/C++%20primer/10.%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="10-3-2lambda表达式"><a href="#10-3-2lambda表达式" class="headerlink" title="10.3.2lambda表达式"></a>10.3.2lambda表达式</h3><p><strong>[capture list] (parameter list) -&gt; return type{function body}</strong></p><p>capture list捕获列表：局部变量的列表</p><p>必须使用尾置返回类型。</p><p>可以忽略参数列表和返回类型，但是必须包含捕获列表和函数体</p><p>auto f = [] {return 42};</p><p>使用<strong>条件运算符</strong>或者<strong>直接返回</strong>时，不用显式指出返回类型。</p><h3 id="10-3-3lambda捕获和返回"><a href="#10-3-3lambda捕获和返回" class="headerlink" title="10.3.3lambda捕获和返回"></a>10.3.3lambda捕获和返回</h3><p><strong>空捕获列表</strong>：[]</p><p><strong>值捕获</strong>：auto f = [v1] {return v1;};</p><p><strong>引用捕获</strong>：auto f2=[&amp;v1]{return v1;};</p><p>(采用引用捕获必须确保被引用的对象在lambda在执行的时候是存在的。)</p><p>捕获ostream的引用</p><p>[&amp;os,c] (const string &amp;) {os&lt;&lt;s&lt;&lt;c;};</p><p><strong>隐式捕获</strong>：让编译器根据lambda提中的代码推断我们要只用哪些变量。[=]采用捕获值方式，[&amp;]采用捕获引用方式。</p><p>当混合使用隐式捕获和显式捕获，捕获列表中的第一个元素必须是&amp;或者=。</p><p><strong>可变lambda</strong></p><p>值捕获 auto f = [v1] () <strong>mutable</strong>{ return ++v1;};</p><p>引用捕获的变量是否可以修改依赖于此引用指向的是一个const类型还是非const类型。</p><h3 id="10-3-4参数绑定"><a href="#10-3-4参数绑定" class="headerlink" title="10.3.4参数绑定"></a>10.3.4参数绑定</h3><p>多个地方执行相同的操作，通常定义一个函数。</p><p>lambda的捕获列表为空，通常可以用函数代替它。对于捕获列表不为空，情况更复杂。</p><p><strong>bind函数</strong><functional></p><p>可以看成一个通用的函数适配器</p><p>auto newCallable = bind(callable,arg_list)</p><p>arg_list可能包含_1, _2这种占位符，表示生成可调用对象中参数的位置。</p><pre><code class="hljs lisp">auto wc = find_if(<span class="hljs-name">words</span>.begin(), words.end(),bind(<span class="hljs-name">check_size</span>,_1,sz))<span class="hljs-comment">;</span></code></pre><p>using std::placeholders::_1;</p><p>所以使用using namespace placeholder;</p><p><strong>可以用bind绑定给定可调用对象中的参数或重新安排其顺序。</strong></p><p>auto g = bind(f, a, b, _2, c, _1);</p><p>g(X,Y) =&gt; f(a,b,Y,c,X);</p><p><strong>绑定引用参数</strong></p><p>使用标准库<strong>ref</strong>函数</p><pre><code class="hljs lisp">for_each(<span class="hljs-name">words</span>.begin(), words.end(),bind(<span class="hljs-name">print</span>,ref(<span class="hljs-name">os</span>),_1 ,' '))<span class="hljs-comment">;</span></code></pre><h2 id="10-4再探迭代器"><a href="#10-4再探迭代器" class="headerlink" title="10.4再探迭代器"></a>10.4再探迭代器</h2><h3 id="10-4-1插入迭代器"><a href="#10-4-1插入迭代器" class="headerlink" title="10.4.1插入迭代器"></a>10.4.1插入迭代器</h3><p>是一种迭代器适配器</p><p>it=t;//在it指定的当前尾置插入值t。</p><p>插入迭代器的三种类型，在于元素插入尾置：</p><ul><li>back_inserter ：push_back</li><li>front_inserter ：push_front</li><li>inserter: 第二个参数，元素必须被插入给定迭代器所表示的元素之前。</li></ul><p>list<int> lst={1,2,3,4},lst3;</p><p>copy(lst.begin(), lst.end(), inserter(lst3,lst3.begin()));//lst3={1,2,3,4}</p><h3 id="10-4-2-iostream迭代器"><a href="#10-4-2-iostream迭代器" class="headerlink" title="10.4.2 iostream迭代器"></a>10.4.2 iostream迭代器</h3><ul><li>istream_iterator</li></ul><pre><code class="hljs perl">istream_iterator&lt;<span class="hljs-keyword">int</span>&gt; in(cin), <span class="hljs-keyword">eof</span>;<span class="hljs-regexp">//in</span>:从cin读取<span class="hljs-keyword">int</span>，<span class="hljs-keyword">eof</span>: istream尾后迭代器cout &lt;&lt; accumulate(in, <span class="hljs-keyword">eof</span>, <span class="hljs-number">0</span>)&lt;&lt;endl;</code></pre><pre><code class="hljs ebnf"><span class="hljs-attribute">Sales_item sum</span> = *iterm_iter++;</code></pre><ul><li>ostream_iterator</li></ul><pre><code class="hljs cpp"><span class="hljs-function">ostream_iterator&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">out_iter</span><span class="hljs-params">(<span class="hljs-built_in">cout</span>, <span class="hljs-string">" "</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:vec)out_iter=e;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;</code></pre><pre><code class="hljs gauss"><span class="hljs-built_in">copy</span>(<span class="hljs-built_in">vec</span>.<span class="hljs-built_in">begin</span>(),<span class="hljs-built_in">vec</span>.<span class="hljs-keyword">end</span>(),out_iter);</code></pre><h3 id="10-4-3反向迭代器"><a href="#10-4-3反向迭代器" class="headerlink" title="10.4.3反向迭代器"></a>10.4.3反向迭代器</h3><p>只能从既支持++又支持–的迭代器来定义反向迭代器。排除forward_list和流迭代器。</p><ul><li>reverse_iterator</li></ul><p>将反向迭代器转换回普通迭代器需要调用reverse_iterator的base成员。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ primer/15面向对象程序设计</title>
    <link href="/2020/07/05/C++%20primer/15%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/07/05/C++%20primer/15%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="15-面向对象程序设计"><a href="#15-面向对象程序设计" class="headerlink" title="15 面向对象程序设计"></a>15 面向对象程序设计</h1><h2 id="15-1-OOP：概述"><a href="#15-1-OOP：概述" class="headerlink" title="15.1 OOP：概述"></a>15.1 OOP：概述</h2><p>数据抽象：将类的接口与实现分离</p><p>继承：定义相似的类型并对其相似关系建模</p><p>动态绑定：忽略类型的区别，以同一的方式使用它们的对象</p><h3 id="继承（inheritance）"><a href="#继承（inheritance）" class="headerlink" title="继承（inheritance）"></a>继承（inheritance）</h3><p>类构成层次关系。<strong>基类（base class）</strong>、<strong>派生类（derived class）</strong></p><p>基类定义在层次关系中<strong>所有类共同拥有的成员</strong>，而每个派生类定义<strong>各自特有的成员</strong>。</p><p>对于某些函数，基类希望它的派生类各自定义合适自身的版本，基类将这些函数声明成<strong>虚函数（virtual function）</strong>。</p><p>派生类必须使用<strong>类派生列表（class derivation list）</strong>明确指出从哪个基类派生而来。形式：一个冒号，逗号分隔的基类列表，每个基类前有访问说明符。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Bulk_quote</span> : <span class="hljs-symbol">public</span> <span class="hljs-symbol">Quote</span>&#123;</code></pre><p>派生类必须在其内部对所有重新定义的虚函数进行声明。（可以）在这样的函数前加virtual。</p><p>C++11允许派生类显式地注明使用哪个成员函数改写基类的虚函数，<strong>override</strong>关键字。</p><h3 id="动态绑定（dynamic-binding）"><a href="#动态绑定（dynamic-binding）" class="headerlink" title="动态绑定（dynamic binding）"></a>动态绑定（dynamic binding）</h3><pre><code class="hljs reasonml">double print<span class="hljs-constructor">_total(<span class="hljs-params">ostream</span> &amp;<span class="hljs-params">os</span>, <span class="hljs-params">const</span> Quote &amp;<span class="hljs-params">item</span>)</span>&#123;item.net<span class="hljs-constructor">_price()</span>...&#125;</code></pre><p>既能使用基类Quote的对象调用该函数，也能使用派生类Bulk_quote的对象调用它。</p><p>实际传入的对象类型决定执行哪个版本的net_price。</p><p>上述过程中，函数的运行版本由实参决定，即在<strong>运行时</strong>选择函数的版本，所以动态绑定有时也称为<strong>运行时绑定（run-time binding）</strong>。</p><p><strong>使用基类的引用（或指针）调用一个虚函数时发生动态绑定。</strong></p><h2 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h2><h3 id="15-2-1-定义基类"><a href="#15-2-1-定义基类" class="headerlink" title="15.2.1 定义基类"></a>15.2.1 定义基类</h3><p>基类通常定义一个虚析构函数，即使该函数不执行任何实际操作。</p><h4 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h4><p>区分两种成员函数：</p><ul><li>基类希望派生类override的函数，定义为虚函数</li><li>基类希望派生类直接继承的函数</li></ul><p><strong>任何构造函数之外的非静态函数都可以是虚函数。</strong></p><p>关键字virtual只能出现在<strong>类内部</strong>的声明语句之前。</p><p>基类中声明虚函数，在派生类中隐式地也是虚函数。</p><p>成员函数如果没有声明为虚函数，则其解析过程发生在编译时而非运行时。</p><h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><p>和其他使用基类的代码一样，派生类能够访问公有成员，而不能访问私有成员。</p><p>基类希望派生类有权访问，同时禁止其他用户访问，使用<strong>protected访问运算符</strong>说明这样的成员。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ primer/12.动态内存</title>
    <link href="/2020/07/05/C++%20primer/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <url>/2020/07/05/C++%20primer/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="12动态内存"><a href="#12动态内存" class="headerlink" title="12动态内存"></a>12动态内存</h1><table><thead><tr><th></th><th>分配</th><th>销毁</th></tr></thead><tbody><tr><td>全局对象</td><td>程序启动时</td><td>程序结束时</td></tr><tr><td>局部自动对象</td><td>进入其定义所在程序块</td><td>离开时</td></tr><tr><td>局部static对象</td><td>在第一次使用前</td><td>程序介数时</td></tr><tr><td>动态分配对象</td><td></td><td>显式地释放（与在哪里创建无关）</td></tr></tbody></table><p>静态内存：保存局部static对象。</p><p>栈内存：保存定义在函数内的非static对象。</p><p>分配在静态内存和动态内存中的对象由编译器自动创建和销毁。</p><p>程序拥有内存池，称为自由空间或堆（heap）。用来存储动态分配的对象。</p><h2 id="12-1动态内存与智能指针"><a href="#12-1动态内存与智能指针" class="headerlink" title="12.1动态内存与智能指针"></a>12.1动态内存与智能指针</h2><p>动态内存的管理，一对运算符new、delete</p><p>动态内存的使用容易出问题：内存泄漏（没有释放内存）、引用非法内存的指针（提前释放）、二次delete</p><p>智能指针：负责自动释放所指对象</p><p>shared_ptr、unique_ptr、weak_prt <memory></p><h3 id="12-1-1-shared-ptr类"><a href="#12-1-1-shared-ptr类" class="headerlink" title="12.1.1 shared_ptr类"></a>12.1.1 shared_ptr类</h3><p>shared_ptr<string> p1;</p><p>默认初始化的智能指针保存着一个空指针</p><p><strong>make_shared<T> (args)//返回一个shared_ptr，指向一个动态分配的类型为T的对象</strong></p><p>shared_ptr<T>p(q)//p是q的拷贝，递增q中的计数器</p><p>p = q//递减p的引用计数、递增q的引用计数</p><p>p.unique()//p.use_count()==1</p><p>p.use_count()//与p共享对象的智能指针数量</p><p>当指向一个对象最后一个shared_ptr呗毁坏掉，shared_ptr类会自动销毁此对象。通过析构函数。</p><p>shared_ptr保存在局部变量中，在代码块结束后被释放掉。但是，如果返回p，引用计数增加，p离开作用域不会被释放掉。</p><p>分配的资源与对象的生存期一致。分配的资源与对象的生存期相独立。（共享相同的底层元素）</p><p><strong>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</strong></p><h3 id="12-1-2-直接内存管理"><a href="#12-1-2-直接内存管理" class="headerlink" title="12.1.2 直接内存管理"></a>12.1.2 直接内存管理</h3><p>在自由空间分配的内存是无名的，new无法为其分配的对象命名，而是返回一个指向该对象的指针。</p><p><strong>new:构造一个对象，返回指向该对象的指针。</strong></p><p>一个动态分配的const对象必须进行初始化。new返回的指针是一个指向const的指针。</p><p><strong>const</strong> int <em>pci = new *</em>const** int(1024);</p><p>内存耗尽，抛出异常bad_alloc。改变new的方式阻止它抛出异常。定位new(placement new)，允许我们向new传递额外的参数。</p><p>int <em>p = new *</em>(nothrow)** int;</p><p><strong>delete:销毁该给定指针指向的对象，释放对应的内存。</strong></p><p>释放空指针不会产生错误，但是释放已经释放过的指针会产生错误。</p><p>坚持使用智能指针避免动态内存使用的常见问题。</p><p>delete之后，指针变成空悬指针(dangling pointer)。==指针离开作用域前释放掉关联的内存。==delete后，将nullptr赋予指针。</p><h3 id="12-1-3-shared-ptr和new结合使用"><a href="#12-1-3-shared-ptr和new结合使用" class="headerlink" title="12.1.3 shared_ptr和new结合使用"></a>12.1.3 shared_ptr和new结合使用</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ primer/11.关联容器</title>
    <link href="/2020/07/05/C++%20primer/11.%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <url>/2020/07/05/C++%20primer/11.%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="第11章关联容器"><a href="#第11章关联容器" class="headerlink" title="第11章关联容器"></a>第11章关联容器</h1><p>associative-container</p><p>关联容器支持高效的关键字的查找和访问。</p><p>两个主要的关联容器<strong>类型</strong>：set和map。</p><p>允许重复关键字multi_</p><p>不保持关键字顺序unordered_(哈希函数组织的)</p><p>标准库提供8个关联容器。头文件<map> <set> <unordered_map> <unordered_set></p><h2 id="11-1使用关联容器"><a href="#11-1使用关联容器" class="headerlink" title="11.1使用关联容器"></a>11.1使用关联容器</h2><p>map使用[key]。如果key没有在map中，下标运算符会创建一个新元素。</p><p>set 使用下标运算符访问。判断是否存在元素Key。if(set.find(key)==set.end())</p><h2 id="11-2关联容器概述"><a href="#11-2关联容器概述" class="headerlink" title="11.2关联容器概述"></a>11.2关联容器概述</h2><p>关联容器的迭代器都是双向的。</p><h3 id="11-2-1定义关联容器"><a href="#11-2-1定义关联容器" class="headerlink" title="11.2.1定义关联容器"></a>11.2.1定义关联容器</h3><p>空容器</p><p>列表初始化</p><pre><code class="hljs cpp"><span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>&gt; exclude = &#123;<span class="hljs-string">"the"</span>,<span class="hljs-string">"big"</span>,<span class="hljs-string">"band"</span>&#125;;<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt; ages=&#123;&#123;<span class="hljs-string">"Alice"</span>,<span class="hljs-number">18</span>&#125;,&#123;<span class="hljs-string">"Bob"</span>,<span class="hljs-number">24</span>&#125;&#125;;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
